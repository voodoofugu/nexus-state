import{useReducer as t,useRef as e,useState as n,useEffect as s,useSyncExternalStore as o}from"react";function r(t){const{state:e,actions:n}=t;let s=Object.assign({},e);const o=new Map,r=[],c=t=>{var e;"*"===t?o.forEach((t=>t.forEach((t=>t())))):(t.forEach((t=>{var e;return null===(e=o.get(t))||void 0===e?void 0:e.forEach((t=>t()))})),null===(e=o.get("*"))||void 0===e||e.forEach((t=>t())))},u=t=>{const e=Object.assign({},s),n="function"==typeof t?t(e):t;let o=Object.assign(Object.assign({},s),n);for(const t of r){const n=t(e,o);void 0!==n&&(o=n)}const u=[];for(const t in o)Object.prototype.hasOwnProperty.call(o,t)&&s[t]!==o[t]&&u.push(t);u.length&&(s=o,c(u))},i={getNexus:function(t){return void 0!==t?s[t]:s},setNexus:u,nexusReset:()=>{s=Object.assign({},e),c("*")},nexusSubscribe:(t,e)=>{const n=Array.isArray(t)?t:[t];return n.forEach((t=>{o.has(t)||o.set(t,new Set),o.get(t).add(e)})),()=>{n.forEach((t=>{var n;return null===(n=o.get(t))||void 0===n?void 0:n.delete(e)}))}},nexusGate:t=>{r.push(t)}},a={};if(Array.isArray(n))for(const t of n){const e=t.call(a,u);e&&"object"==typeof e&&Object.assign(a,e)}else if("function"==typeof n){const t=n.call(a,u);t&&"object"==typeof t&&Object.assign(a,t)}for(const t of Object.keys(a)){const e=a[t];"function"==typeof e&&(a[t]=e.bind(a))}return{state:i,actions:a}}function c(c){const{state:u,actions:i}=r(c),a=i;return{state:Object.assign(Object.assign({},u),{useNexus:function(t){return o((e=>u.nexusSubscribe(t?[t]:"*",e)),(()=>{const e=u.getNexus();return t?e[t]:e}))},useNexusSelector:function(t,o){const r=e(t(u.getNexus())),[c,i]=n(r.current);return s((()=>{const e=()=>{const e=t(u.getNexus());e!==r.current&&(r.current=e,i(e))},n=u.nexusSubscribe(o,e);return e(),n}),[o,t]),c},useUpdate:()=>{const[,e]=t((()=>({})),{});return e}}),actions:a}}function u(t){return function(e){return t.call(this,e)}}function i(t){return function(e){return t.call(this,e)}}export{u as createActions,i as createDiscreteActions,c as createReactStore,r as createStore};
